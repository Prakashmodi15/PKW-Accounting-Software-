<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Unlimited Polygon Editor — Prakash (Live)</title>
<style>
:root{--bg:#f6f9ff;--panel:#fff;--accent:#163aa2;--muted:#333}
html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial}
.container{max-width:1200px;margin:10px auto;padding:12px}
.header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
.header img{height:54px;border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
.canvasWrap{background:var(--panel);border-radius:10px;padding:10px;box-shadow:0 10px 30px rgba(10,20,40,0.06);position:relative}
#cv{width:100%;height:520px;border-radius:8px;background:#fff;display:block;touch-action:none}
.side{display:grid;grid-template-columns:1fr 380px;gap:12px;margin-top:12px}
.panel{background:var(--panel);padding:10px;border-radius:8px;box-shadow:0 8px 26px rgba(10,20,30,0.04);height:520px;overflow:auto}
.toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
.btn{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
.btn.secondary{background:#eef6ff;color:var(--accent)}
.inputTiny{width:110px;padding:6px;border-radius:6px;border:1px solid #ddd}
.vertexItem{padding:8px;border-radius:8px;border:1px solid #f0f0f0;margin-bottom:8px;background:#fff;display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
.small{font-size:13px;color:var(--muted)}
.inline{position:absolute;display:none;background:#fff;border-radius:8px;padding:8px;box-shadow:0 12px 36px rgba(0,0,0,0.12);z-index:60}
.note{font-size:12px;color:#666}
.kv{font-size:13px;color:#333}
.hr{height:1px;background:#f1f5f9;margin:10px 0;border-radius:2px}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <!-- local screenshot included as reference (developer requested to use this path) -->
    <img src="/mnt/data/Screenshot_20251125_164054_Naapi Amin Land Calculator.jpg" alt="ref"/>
    <div>
      <h2 style="margin:0">Unlimited Polygon Editor — Prakash</h2>
      <div class="note">Canvas ऊपर • Data panel दाहिने • Double-click vertex to edit exact X,Y • Click+move &gt;6px to start drag</div>
    </div>
  </div>

  <div class="canvasWrap">
    <canvas id="cv" tabindex="0"></canvas>
    <div id="inline" class="inline" aria-hidden="true">
      <div id="inlineTitle" style="font-weight:700;margin-bottom:6px">Edit</div>
      <input id="inlineInput" style="width:260px;padding:6px;border:1px solid #ddd;border-radius:6px" />
    </div>
  </div>

  <div class="side">
    <div class="panel" id="leftPanel">
      <div class="toolbar">
        <button id="addPt" class="btn secondary">Add Vertex</button>
        <button id="delPt" class="btn secondary">Delete Selected</button>
        <button id="resetBtn" class="btn secondary">Reset</button>
        <button id="gridToggle" class="btn secondary">Grid</button>
        <button id="constructToggle" class="btn secondary">Construct</button>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <label class="small">Scale (1 unit = meters)</label>
        <input id="unitScale" class="inputTiny" value="1" />
      </div>

      <div class="hr"></div>
      <div class="kv"><strong>Vertices & edit</strong> — क्लिक कर select करें, value बदलते ही shape realtime update होगा</div>
      <div id="vertexList" style="margin-top:10px"></div>
    </div>

    <div class="panel" id="rightPanel">
      <h3 style="margin-top:0">Metrics</h3>
      <div class="kv">Vertices: <span id="vcount">0</span></div>
      <div class="kv">Perimeter: <span id="peri">—</span> units</div>
      <div class="kv">Area (units²): <span id="areaUnits">—</span></div>
      <div class="kv">Area (m²): <span id="areaMeters">—</span></div>
      <div class="kv">Area (ft²): <span id="areaFeet">—</span></div>
      <div class="kv">Area (acres): <span id="areaAcre">—</span></div>

      <div class="hr"></div>
      <div class="note">Editing rules:
        <ul>
          <li>Change X/Y → vertex moves.</li>
          <li>Change Length (this→next) → next vertex moved along current direction.</li>
          <li>Change Length (prev→this) → this vertex moved along current direction from prev.</li>
          <li>Change Angle at vertex → next vertex rotated around vertex to satisfy angle (length preserved).</li>
        </ul>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="exportSVG" class="btn">Export SVG</button>
        <button id="exportPNG" class="btn">Export PNG</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------------------------------------------------------
   Unlimited Polygon Editor — Prakash
   - Unlimited closed polygon
   - Vertex drag (click → move >6px → drag)
   - Sidebar editable: X, Y, prev-side, next-side, angle
   - Real-time updates: edges lengths labels, area, metrics
   - Double-click to edit exact coords
   --------------------------------------------------------- */

const canvas = document.getElementById('cv'), ctx = canvas.getContext('2d');
const wrap = document.querySelector('.canvasWrap');
const vertexList = document.getElementById('vertexList');
const inline = document.getElementById('inline'), inlineInput = document.getElementById('inlineInput'), inlineTitle = document.getElementById('inlineTitle');
const periEl = document.getElementById('peri'), areaUnitsEl = document.getElementById('areaUnits'), areaMetersEl = document.getElementById('areaMeters'), areaFeetEl = document.getElementById('areaFeet'), areaAcreEl = document.getElementById('areaAcre');
const vcountEl = document.getElementById('vcount');
const unitScaleEl = document.getElementById('unitScale');

let pxPerUnit = 4.0; // pixels per "unit"
let unitToMeters = parseFloat(unitScaleEl.value) || 1;

let points = [];           // array of {x,y} px (screen coords)
let selectedIdx = null;

// drag state
let pointerDown = false, pointerDownIdx = null, pointerDownPos = null, draggingIdx = null;
const DRAG_THRESHOLD = 6;

let showGrid = false, showConstruct = false;

// do proper canvas pixel sizing for crispness
function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', ()=>{ fitCanvas(); render(); });
fitCanvas();

// basic helpers
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function round2(x){ return Math.round(x*100)/100; }
function toUnits(px){ return px / pxPerUnit; }
function fromUnits(u){ return u * pxPerUnit; }
function deg(r){ return r*180/Math.PI; }
function rad(d){ return d*Math.PI/180; }
function angleBetween(v1,v2){ const dot = v1.x*v2.x + v1.y*v2.y; const det = v1.x*v2.y - v1.y*v2.x; return Math.atan2(det, dot); }
function rotatePointAround(p, center, theta){ const dx = p.x-center.x, dy = p.y-center.y; const cx = dx*Math.cos(theta)-dy*Math.sin(theta); const cy = dx*Math.sin(theta)+dy*Math.cos(theta); return {x:center.x+cx, y:center.y+cy}; }

// polygon metrics
function sideLenPx(i){ if(points.length<2) return 0; const A=points[i], B=points[(i+1)%points.length]; return dist(A,B); }
function sideLenUnits(i){ return toUnits(sideLenPx(i)); }
function internalAngleDeg(i){
  if(points.length<3) return 0;
  const prev = points[(i-1+points.length)%points.length], cur = points[i], next = points[(i+1)%points.length];
  const v1 = {x: prev.x - cur.x, y: prev.y - cur.y}, v2 = {x: next.x - cur.x, y: next.y - cur.y};
  const ang = Math.abs(angleBetween(v1,v2));
  return deg(ang);
}
function perimeterUnits(){ let p=0; for(let i=0;i<points.length;i++) p += sideLenUnits(i); return p; }
function areaUnits(){
  if(points.length<3) return 0;
  let s = 0;
  for(let i=0;i<points.length;i++){
    const a = points[i], b = points[(i+1)%points.length];
    s += a.x*b.y - b.x*a.y;
  }
  const areaPx = Math.abs(s) / 2;
  return (areaPx / (pxPerUnit * pxPerUnit));
}

// drawing
function drawGrid(){
  if(!showGrid) return;
  const gap = 25;
  ctx.save();
  ctx.strokeStyle = '#eef6ff'; ctx.lineWidth = 1;
  const w = canvas.width / (window.devicePixelRatio||1);
  const h = canvas.height / (window.devicePixelRatio||1);
  for(let x=0;x<w;x+=gap){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<h;y+=gap){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.restore();
}

function angleBisectorPoint(V,P1,P2){
  const a = dist(P1,P2), b = dist(V,P1), c = dist(V,P2);
  if(b < 1e-9 || c < 1e-9) return null;
  const ux = (P1.x - V.x)/b + (P2.x - V.x)/c;
  const uy = (P1.y - V.y)/b + (P2.y - V.y)/c;
  const mag = Math.hypot(ux, uy); if(mag < 1e-9) return null;
  const L = Math.max(30, (b+c)/6);
  return { x: V.x + (ux/mag)*L, y: V.y + (uy/mag)*L };
}

function draw(){
  fitCanvas();
  const w = canvas.width / (window.devicePixelRatio||1);
  const h = canvas.height / (window.devicePixelRatio||1);
  ctx.clearRect(0,0,w,h);

  drawGrid();

  // edges + labels
  if(points.length >= 2){
    for(let i=0;i<points.length;i++){
      const A = points[i], B = points[(i+1)%points.length];
      ctx.beginPath(); ctx.strokeStyle = '#163aa2'; ctx.lineWidth = 3; ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();

      // midpoint length label
      const mx = (A.x+B.x)/2, my = (A.y+B.y)/2;
      const lenU = round2(toUnits(dist(A,B)));
      ctx.font = '13px system-ui'; ctx.fillStyle = '#000';
      ctx.fillText(lenU, mx + 8, my - 6);

      // small perpendicular tick
      ctx.beginPath();
      const dx = B.x - A.x, dy = B.y - A.y;
      const nx = -dy, ny = dx; const nlen = Math.hypot(nx,ny) || 1;
      ctx.moveTo(mx - (nx/nlen)*6, my - (ny/nlen)*6);
      ctx.lineTo(mx + (nx/nlen)*6, my + (ny/nlen)*6);
      ctx.strokeStyle = '#e6eef8'; ctx.lineWidth = 1; ctx.stroke();
    }
  }

  // constructions: bisectors
  if(showConstruct && points.length >= 3){
    for(let i=0;i<points.length;i++){
      const cur = points[i], prev = points[(i-1+points.length)%points.length], next = points[(i+1)%points.length];
      const bis = angleBisectorPoint(cur, prev, next);
      if(bis){
        ctx.beginPath(); ctx.strokeStyle = '#27ae60'; ctx.setLineDash([6,4]);
        ctx.moveTo(cur.x, cur.y); ctx.lineTo(bis.x, bis.y); ctx.lineWidth = 1.2; ctx.stroke(); ctx.setLineDash([]);
      }
    }
  }

  // vertices and internal angles
  for(let i=0;i<points.length;i++){
    const p = points[i];
    ctx.beginPath(); ctx.fillStyle = (i===selectedIdx)?'#0b74de':'#000'; ctx.arc(p.x,p.y,(i===selectedIdx)?8:6,0,Math.PI*2); ctx.fill();
    ctx.font = '12px system-ui'; ctx.fillStyle = '#111'; ctx.fillText('#' + i, p.x + 10, p.y - 8);
    if(points.length >= 3){
      ctx.fillText('θ=' + round2(internalAngleDeg(i)) + '°', p.x + 10, p.y + 14);
    }
  }

  // update metrics
  vcountEl.textContent = points.length;
  periEl.textContent = points.length >= 2 ? round2(perimeterUnits()) : '—';
  const areaU = areaUnits();
  areaUnitsEl.textContent = points.length >= 3 ? round2(areaU) : '—';
  const areaM = areaU * (unitToMeters * unitToMeters);
  areaMetersEl.textContent = points.length >= 3 ? round2(areaM) + ' m²' : '—';
  areaFeetEl.textContent = points.length >= 3 ? round2(areaM * 10.763910417) + ' ft²' : '—';
  areaAcreEl.textContent = points.length >= 3 ? round2(areaM / 4046.8564224) + ' acres' : '—';

  renderVertexList();
}

// helpers used above
function internalAngleDeg(i){
  if(points.length < 3) return 0;
  const prev = points[(i-1+points.length)%points.length], cur = points[i], next = points[(i+1)%points.length];
  const v1 = {x: prev.x - cur.x, y: prev.y - cur.y}, v2 = {x: next.x - cur.x, y: next.y - cur.y};
  const ang = Math.abs(angleBetween(v1, v2));
  return deg(ang);
}
function perimeterUnits(){ let p = 0; for(let i=0;i<points.length;i++) p += sideLenUnits(i); return p; }
function sideLenUnits(i){ return toUnits(sideLenPx(i)); }
function sideLenPx(i){ if(points.length < 2) return 0; const A = points[i], B = points[(i+1)%points.length]; return dist(A,B); }
function areaUnits(){ if(points.length < 3) return 0; let s = 0; for(let i=0;i<points.length;i++){ const a = points[i], b = points[(i+1)%points.length]; s += a.x * b.y - b.x * a.y; } const areaPx = Math.abs(s)/2; return areaPx / (pxPerUnit * pxPerUnit); }

// sidebar / list rendering
function renderVertexList(){
  vertexList.innerHTML = '';
  for(let i=0;i<points.length;i++){
    const div = document.createElement('div'); div.className = 'vertexItem';
    const left = document.createElement('div'); left.innerHTML = `<strong>Vertex ${i}</strong><div class="small">x:${Math.round(points[i].x)}, y:${Math.round(points[i].y)}</div>`;
    const right = document.createElement('div');
    const lenPrev = round2(toUnits(dist(points[(i-1+points.length)%points.length]||points[i], points[i])));
    const lenNext = round2(toUnits(dist(points[i], points[(i+1)%points.length]||points[i])));
    const ang = points.length >= 3 ? round2(internalAngleDeg(i)) : 0;
    right.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <input data-idx="${i}" data-type="x" class="inputTiny" value="${Math.round(points[i].x)}" />
        <input data-idx="${i}" data-type="y" class="inputTiny" value="${Math.round(points[i].y)}" />
        <div style="display:flex;gap:6px">
          <input data-idx="${i}" data-type="lenPrev" class="inputTiny" title="Length prev->this (units)" value="${lenPrev}" />
          <input data-idx="${i}" data-type="lenNext" class="inputTiny" title="Length this->next (units)" value="${lenNext}" />
        </div>
        <input data-idx="${i}" data-type="angle" class="inputTiny" value="${ang}" />
      </div>
    `;
    div.appendChild(left); div.appendChild(right);
    div.addEventListener('click', ()=>{ selectedIdx = i; render(); });
    // attach listeners to inputs
    setTimeout(()=>{ const ins = div.querySelectorAll('input'); ins.forEach(inp=>{ inp.addEventListener('change', onVertexInputChange); inp.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') inp.blur(); }); }); }, 0);
    vertexList.appendChild(div);
  }
}

// handle sidebar edits
function onVertexInputChange(e){
  const el = e.target, idx = parseInt(el.dataset.idx, 10), type = el.dataset.type, val = parseFloat(el.value);
  if(isNaN(val)) return;
  if(type === 'x'){ points[idx].x = val; render(); return; }
  if(type === 'y'){ points[idx].y = val; render(); return; }
  if(type === 'lenNext'){
    if(points.length < 2) return;
    const A = points[idx], B = points[(idx+1)%points.length];
    const dir = {x: B.x - A.x, y: B.y - A.y};
    const cur = Math.hypot(dir.x, dir.y); if(cur < 1e-9) return;
    const newLenPx = fromUnits(val);
    const s = newLenPx / cur;
    points[(idx+1)%points.length] = { x: A.x + dir.x * s, y: A.y + dir.y * s };
    render(); return;
  }
  if(type === 'lenPrev'){
    if(points.length < 2) return;
    const prev = points[(idx-1+points.length)%points.length], curp = points[idx];
    const dir = { x: curp.x - prev.x, y: curp.y - prev.y };
    const curL = Math.hypot(dir.x, dir.y); if(curL < 1e-9) return;
    const newLenPx = fromUnits(val);
    const s = newLenPx / curL;
    points[idx] = { x: prev.x + dir.x * s, y: prev.y + dir.y * s };
    render(); return;
  }
  if(type === 'angle'){
    if(points.length < 3) return;
    const desiredDeg = val;
    const prev = points[(idx-1+points.length)%points.length], cur = points[idx], next = points[(idx+1)%points.length];
    const vPrev = { x: prev.x - cur.x, y: prev.y - cur.y };
    const vNext = { x: next.x - cur.x, y: next.y - cur.y };
    const signed = angleBetween(vPrev, vNext);
    const desiredRad = Math.abs(rad(desiredDeg));
    const delta = (desiredRad - Math.abs(signed)) * Math.sign(signed || 1);
    const newNextPoint = rotatePointAround({ x: cur.x + vNext.x, y: cur.y + vNext.y }, cur, delta);
    const origLen = Math.hypot(vNext.x, vNext.y);
    const vect = { x: newNextPoint.x - cur.x, y: newNextPoint.y - cur.y };
    const vectLen = Math.hypot(vect.x, vect.y) || 1;
    const scale = origLen / vectLen;
    points[(idx+1)%points.length] = { x: cur.x + vect.x * scale, y: cur.y + vect.y * scale };
    render(); return;
  }
}

// pointer interactions: click then move > threshold to start drag
canvas.addEventListener('pointerdown', (ev)=>{
  ev.preventDefault();
  const rect = canvas.getBoundingClientRect(); const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  pointerDown = true; pointerDownPos = {x, y}; pointerDownIdx = hitVertex(x, y);
});
canvas.addEventListener('pointermove', (ev)=>{
  const rect = canvas.getBoundingClientRect(); const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  if(pointerDown && pointerDownIdx !== null && draggingIdx === null){
    const dx = x - pointerDownPos.x, dy = y - pointerDownPos.y;
    if(Math.hypot(dx, dy) >= DRAG_THRESHOLD) draggingIdx = pointerDownIdx; else return;
  }
  if(draggingIdx !== null){
    points[draggingIdx].x = Math.round(x); points[draggingIdx].y = Math.round(y);
    render();
  }
});
canvas.addEventListener('pointerup', ()=>{ pointerDown = false; pointerDownIdx = null; draggingIdx = null; });
canvas.addEventListener('dblclick', (ev)=>{
  const rect = canvas.getBoundingClientRect(); const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  const idx = hitVertex(x, y); if(idx === null) return; openInlineVertex(idx, x, y);
});

function hitVertex(x, y){
  for(let i=0;i<points.length;i++){ if(Math.hypot(points[i].x - x, points[i].y - y) < 12) return i; }
  return null;
}

// inline editor (double-click)
let popupTarget = null;
function openInlineVertex(idx, clientX, clientY){
  popupTarget = { type:'vertex', idx };
  inlineTitle.textContent = 'Vertex ' + idx + ' (x,y)';
  inlineInput.value = Math.round(points[idx].x) + ', ' + Math.round(points[idx].y);
  showInlineAt(clientX, clientY);
  inlineInput.focus(); inlineInput.select();
}
function showInlineAt(clientX, clientY){
  const rect = wrap.getBoundingClientRect();
  let left = clientX - rect.left + 6, top = clientY - rect.top + 6;
  left = Math.min(left, rect.width - 280); top = Math.min(top, rect.height - 80);
  inline.style.left = left + 'px'; inline.style.top = top + 'px'; inline.style.display = 'block'; inline.setAttribute('aria-hidden', 'false');
}
function hideInline(){ inline.style.display='none'; inline.setAttribute('aria-hidden','true'); popupTarget = null; }
inlineInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ applyInline(); } if(e.key === 'Escape'){ hideInline(); }});
function applyInline(){
  if(!popupTarget) { hideInline(); return; }
  if(popupTarget.type === 'vertex'){
    const parts = inlineInput.value.split(',').map(s=>parseFloat(s.trim()));
    if(parts.length>=2 && !isNaN(parts[0]) && !isNaN(parts[1])){
      points[popupTarget.idx].x = parts[0]; points[popupTarget.idx].y = parts[1]; render(); hideInline(); return;
    } else { alert('Enter valid x,y numbers'); return; }
  }
}

// controls: add/delete/reset/grid/construct/export
function addVertex(){
  const cx = (canvas.getBoundingClientRect().width)/2 + (Math.random()*120 - 60);
  const cy = (canvas.getBoundingClientRect().height)/2 + (Math.random()*120 - 60);
  points.push({ x: Math.round(cx), y: Math.round(cy) });
  render();
}
document.getElementById('addPt').addEventListener('click', addVertex);
document.getElementById('delPt').addEventListener('click', ()=>{
  if(selectedIdx !== null && selectedIdx >= 0 && selectedIdx < points.length){
    points.splice(selectedIdx, 1);
    selectedIdx = null; render();
  } else alert('Select a vertex first (click on vertex).');
});
document.getElementById('resetBtn').addEventListener('click', resetSample);
function resetSample(){
  points = [
    {x:140,y:180},{x:300,y:140},{x:460,y:190},{x:520,y:300},{x:390,y:420},{x:220,y:360}
  ];
  selectedIdx = null; render();
}
document.getElementById('gridToggle').addEventListener('click',(e)=>{ showGrid = !showGrid; e.target.textContent = showGrid? 'Grid: ON':'Grid'; render(); });
document.getElementById('constructToggle').addEventListener('click',(e)=>{ showConstruct = !showConstruct; e.target.textContent = showConstruct? 'Construct: ON':'Construct'; render(); });
unitScaleEl.addEventListener('change', ()=>{ unitToMeters = parseFloat(unitScaleEl.value) || 1; render(); });

function exportSVG(){
  if(points.length < 2){ alert('No polygon'); return; }
  const svgW = canvas.width / (window.devicePixelRatio||1), svgH = canvas.height / (window.devicePixelRatio||1);
  let path = '';
  points.forEach((p,i)=>{ path += (i===0? 'M' : 'L') + p.x + ' ' + p.y + ' '; });
  if(points.length >= 3) path += 'Z';
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}"><path d="${path}" fill="none" stroke="#163aa2" stroke-width="4" stroke-linejoin="round" stroke-linecap="round" /></svg>`;
  const blob = new Blob([svg], { type:'image/svg+xml' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'polygon.svg'; a.click(); URL.revokeObjectURL(url);
}
function exportPNG(){ const link = document.createElement('a'); link.download = 'polygon.png'; link.href = canvas.toDataURL('image/png'); link.click(); }

// start with sample
resetSample();

// expose a render for debug (optional)
function render(){ draw(); }

</script>
</body>
</html>
